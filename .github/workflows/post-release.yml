run-name: '[${{ github.ref_name }}] Post release'

on:
  release: # Run on every release to add new version information.
    types: [released]
  schedule: # Run once a week to detect and manage out-of-support versions.
    - cron: '0 0 * * 3' # Run at the start of every Wednesday as most releases are made on Patch Tuesday.


# Only process one release at a time so we can generate cumulative results in the same PR.
concurrency:
  group: post-release-workflow
  cancel-in-progress: false

permissions: {}

jobs:
  update-shipping-branch:
    name: 'Update shipping branch'
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout
        uses: actions/checkout@8f4b7f84864484a7bf31766abe9204da3cbe65b3
        with:
          persist-credentials: false

      - name: Calculate branch name
        uses: actions/github-script@98814c53be79b1d30f795b907e553d8679345975
        id: calculate-branch-name
        with:
          result-encoding: string
          script: |
            console.log(context);
            console.log(context.payload);
            const actionUtils = require('./.github/actions/action-utils.js')
            const [major, minor] = actionUtils.splitVersionTag(context.payload.release.tag_name)
            return `shipped/v${major}.${minor}`;

      - name: Create or update shipped branch
        uses: actions/github-script@98814c53be79b1d30f795b907e553d8679345975
        with:
          script: |
            const branchName = `${{ steps.calculate-branch-name.outputs.result }}`;
            const refName = `heads/${branchName}`;

            // Check if the ref already exists, if so we will need to fast forward it.
            let needToCreateRef = true;
            try {
              await github.rest.git.getRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: refName
              });
              needToCreateRef = false;
            } catch {
            }

            if (needToCreateRef) {
              await github.rest.git.createRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                sha: context.sha,
                ref: `refs/${refName}`
              });
            } else {
              await github.rest.git.updateRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                sha: context.sha,
                ref: refName,
                force: true
              });
            }

            //
            // Trigger branch mirror, empty commits and new refs will **not** trigger mirroring.
            // The simplest way of doing this is to create an empty file on the desired branch.
            //
            await github.rest.repos.createOrUpdateFileContents({
              owner: context.repo.owner,
              repo: context.repo.repo,
              branch: branchName,
              message: 'Trigger branch mirroring',
              path: '.mirror',
              content: ''
            });

  # Always run this job regardless of the triggering event to keep this workflow simple.
  calculate-supported-frameworks:
    name: 'Calculated supported frameworks'
    runs-on: ubuntu-latest
    outputs:
      result: ${{ steps.scan.outputs.supported_frameworks }}

    # Spin a managed build and analyze the output to determine the supported frameworks for a given commit.
    # It's simpler than trying to parse our `eng/Versions.prop` due to the conditionals in it.
    steps:
      - name: Checkout
        uses: actions/checkout@8f4b7f84864484a7bf31766abe9204da3cbe65b3
        with:
          persist-credentials: false

      - name: Build
        id: build
        run: |
          ./build.sh -ci -c Release -skipnative

      - name: Scan supported frameworks
        id: scan
        run: |
          supported_frameworks=$(ls ./artifacts/bin/dotnet-monitor/Release | grep "net" | xargs)

  update-release-information:
    name: 'Update release info'
    needs: calculate-supported-frameworks
    runs-on: ubuntu-latest
    env:
      BASE_BRANCH: manage-released-versions
      TARGET_BRANCH_POSTFIX: postRelease
    permissions:
      contents: write
      pull-requests: write
      discussions: write

    steps:
      - name: Check for SxS release
        id: SxS-check
        uses: actions/github-script@98814c53be79b1d30f795b907e553d8679345975
        with:
          retries: 3
          result-encoding: json
          script: |
            try {
              const prs = await github.paginate(github.rest.pulls.list, {
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'open',
                head: `${context.repo.owner}:bot/${process.env.TARGET_BRANCH_POSTFIX}`,
                base: process.env.BASE_BRANCH
              });

              if (prs !== undefined && prs.length > 0) {
                core.exportVariable('BASE_BRANCH', `bot/${process.env.TARGET_BRANCH_POSTFIX}`);
                return true;
              }
            } catch (error) {
              console.log(error);
            }

            return false;

      - name: Checkout
        uses: actions/checkout@8f4b7f84864484a7bf31766abe9204da3cbe65b3
        with:
          persist-credentials: true # We need to persist credentials inorder to open a PR.
          ref: ${{ env.BASE_BRANCH }}

      - name: Update releases.json
        uses: ./.github/actions/update-releases-json
        with:
          auth_token: ${{ secrets.GITHUB_TOKEN }}
          releases_json_file: ./.github/releases.json
          end_of_support_discussion_category: Announcements
          supported_frameworks: ${{needs.calculate-supported-frameworks.outputs.result}}

      - name: Update releases.md
        uses: ./.github/actions/update-releases-md
        with:
          releases_json_file: ./.github/releases.json
          releases_md_file: ./documentation/releases.md

      - name: Open PR
        uses: ./.github/actions/open-pr
        with:
          files_to_commit: ./.github/releases.json ./documentation/releases.md
          title: "Update release information"
          commit_message: Update releases information for ${{ github.ref_name }}
          body: Update release information.
          branch_name: ${{ env.TARGET_BRANCH_POSTFIX }}
          fail_if_files_unchanged: ${{ github.event.release }} # If we're responding to a release, we must have updates.
          update_if_already_exists: ${{ steps.SxS-check.outputs.result }}
          auth_token: ${{ secrets.GITHUB_TOKEN }}
